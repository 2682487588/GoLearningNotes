### 一、进程内存

进程，这个内存体 **有自己的独立的地址空间，**上级的挂靠单位是操作系统。  **操作系统会以进程为单位，分配系统资源(CPU时间片，内存等资源)**

![img](https://www.topgoer.cn/uploads/golangxiuyang/images/152-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B1.jpeg)

### 二、线程内存

**线程，轻量级线程，是操作系统调度(CPU调度)的最小单位**

![img](https://www.topgoer.cn/uploads/golangxiuyang/images/153-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B2.jpeg)

多个线程"寄生"在同一组线程上，除了有各自的栈空间，其他内存都是共享的

### 三、执行单元

无论是线程还是进程，CPU都一视同仁，分配时间片

![img](https://www.topgoer.cn/uploads/golangxiuyang/images/154-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B3.jpeg)

进程没有开线程，默认就是1线程，那么多线程的进程肯定有优势

### 四、切换问题与协程

#### 线程可以无限制多吗

cpu在内核态切换`执行单元`，就会有时间成本和性能开销

![img](https://www.topgoer.cn/uploads/golangxiuyang/images/156-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B5.jpeg)

- 切换内核栈
- 切换硬件上下文
- 保存寄存器内容
  - 保存之前执行的状态流程
- CPU高速缓存失效

页表查找是一个慢的过程，**表现出来的程序变慢**

`线程执行流程`越多，cpu切换时候成本越大，我们能否让cpu在内核态不切换`执行单元`，而是在用户态执行

上述操作我们不能实现，所以我们需要在用户态加一个`伪执行流程`，协程

![img](https://www.topgoer.cn/uploads/golangxiuyang/images/157-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B6.jpeg)

### 五、协程的切换成本

协程快于线程有两点

- 1.协程切换 **在用户控件执行**，线程切换涉及**特权切换需要内核空间完成**
- 2.**协程切换比**线程切换事情少，线程需要有内核和用户态的切换,系统调用过程

#### 协程切换成本：

**当前协程的CPU寄存器状态保存，然后将需要切换的协程的CPU寄存器状态加载在CPU寄存器就可以了**，协程上下文切换最多 **几十ns**

#### 线程切换成本：

**线程的调度只有拥有最高权限的内核空间才可以完成**，所以线程的切换涉及到**用户空间和内核空间的切换**，也就是特权模式切换，然后需要操作系统调度模块完成**线程调度（task\***struct）









